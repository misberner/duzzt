/*
 * Copyright (c) 2014 by Malte Isberner (https://github.com/misberner).
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

header(spec) ::= <<
/*
 * Automatically generated by Duzzt -- https://github.com/misberner/duzzt/
 * DO NOT EDIT! Your changes will be overridden.
 * Edit the annotation specification of class
 *   <spec.implementation.type>
 * instead.
 */

<package_decl(spec.nonDefaultPackageName)>
>>

package_decl(packageName) ::= <<
<if(packageName)>package <packageName>;<endif>
>>

edsl_source(spec, automaton, generatorClass, generationDate, flags) ::= <<
<header(spec)>

<edsl_class(spec, automaton, generatorClass, generationDate, flags)>
>>

edsl_class(spec, automaton, generatorClass, generationDate, flags) ::= <<
@javax.annotation.<if(flags.java9OrNewer)>processing.<endif>Generated(
	value={"<generatorClass.canonicalName>"},
	comments="Generated by Duzzt -- https://github.com/misberner/duzzt",
	date="<generationDate>")
<if(spec.classPublic)>public <endif><spec.modifier.prefix>class <spec.className><generic_params(spec.implementation.typeParameters)> {
	<automaton_decl(spec, automaton)>
	
	<impl_field_decl(spec)>
	
	<constructors(spec)>
	
	<initial_state_methods(spec, automaton)>
}

>>

state_class_name(spec, state) ::= "<if(state.initial)><spec.className><generic_args(spec.implementation.typeParameters)><else><spec.className>__<state.id><endif>"
state_field_name(spec, state) ::= "__duzzt_state<state.id>"
state_field_decl(spec, state) ::= "private <state_class_name(spec, state)> <state_field_name(spec, state)> = null;"
 
state_accessor_name(spec, state) ::= "__duzzt_getState<state.id>"

access_state(spec, state) ::= "<spec.className>.this<if(!state.initial)>.<state_accessor_name(spec, state)>()<endif>"

state_accessor_impl(spec, state) ::= <<
private <state_class_name(spec, state)> <state_accessor_name(spec, state)>() {
	if(this.<state_field_name(spec, state)> == null) {
		this.<state_field_name(spec, state)> = new <state_class_name(spec, state)>();
	}
	return this.<state_field_name(spec, state)>;
}
>>

automaton_decl(spec, automaton) ::= <<
<automaton.states:{s|<automaton_state_decl(spec, s)>}; separator="\n">
>>

automaton_state_decl(spec, state) ::= <<
<if(!state.initial)>
<state_class_decl(spec, state)>
<state_field_decl(spec, state)>
<state_accessor_impl(spec, state)>
<endif>
>>

state_class_decl(spec, state) ::= <<
public final class <state_class_name(spec, state)> {
	<state.transitions:{t|<state_transition(spec, t)>}; separator="\n">
}
>>

state_transition(spec, trans) ::= <<
<if(trans.successor)><nonterm_transition(spec, trans)><else><terminator_transition(spec, trans.action)><endif>
>>

nonterm_transition(spec, trans) ::= <<
<if(trans.action.hasVarArgsParams)>@SafeVarargs<endif>
public final <generic_params(trans.action.typeParameters)>
<state_class_name(spec, trans.successor)> <trans.action.name>(<params(trans.action.parameters)>)<throws_spec(trans.action.thrownTypes)> {
	<access_impl(spec)>.<trans.action.method.simpleName>(<args(trans.action.parameters)>);
	return <access_state(spec, trans.successor)>;
}
<if(trans.varArgsApplicable)><varargs_transition(spec, trans)><endif>
>>

varargs_transition(spec, trans) ::= <<
@SafeVarargs
public final <generic_params(trans.action.typeParameters)>
<state_class_name(spec, trans.successor)> <trans.action.name>(<params(trans.action.parameters)>, <last(trans.action.parameters).type>... <last(trans.action.parameters).name>s)<throws_spec(trans.action.thrownTypes)> {
	<state_class_name(spec, trans.successor)> __duzzt_succ = <trans.action.name>(<args(trans.action.parameters)>);
	for(<last(trans.action.parameters).type> __duzzt_varargs_elem : <last(trans.action.parameters).name>s) {
		__duzzt_succ.<trans.action.name>(<args(trunc(trans.action.parameters))><if(trunc(trans.action.parameters))>, <endif>__duzzt_varargs_elem);
	}
	return __duzzt_succ;
}
>>

terminator_transition(spec, action) ::= <<
public <generic_params(action.typeParameters)>
<action.returnType> <action.name>(<params(action.parameters)>)<throws_spec(action.thrownTypes)> {
	<if(!action.void)>return <endif><access_impl(spec)>.<action.method.simpleName>(<args(action.parameters)>);
}
>>

impl_field_name(spec) ::= "__duzzt_impl"
impl_field_decl(spec) ::= "private final <spec.implementation.type><generic_args(spec.implementation.typeParameters)> <impl_field_name(spec)>;"
access_impl(spec) ::= "<spec.className>.this.<impl_field_name(spec)>"


initial_state_methods(spec, automaton) ::= <<
<automaton.initialState.transitions:{t|<state_transition(spec, t)>}; separator="\n">
>>

constructors(spec) ::= <<
<forward_constructors(spec)>

<delegate_constructor(spec)>
>>


forward_constructors(spec) ::= <<
<spec.forwardConstructors:{fc|<forward_constructor(spec, fc)>}; separator="\n">
>>

delegate_constructor(spec) ::= <<
<spec.delegateConstructorVisibility.prefix><spec.className>(<spec.implementation.type><generic_args(spec.implementation.typeParameters)> implementation) {
	this.<impl_field_name(spec)> = implementation;
}
>>

forward_constructor(spec, fc) ::= <<
<fc.visibility.prefix><generic_params(fc.typeParameters)><spec.className>(<fc.parameters;separator=", ">)<throws_spec(fc.thrownTypes)> {
	this.<impl_field_name(spec)> = new <generic_args(fc.typeParameters)><spec.implementation.type><generic_args(spec.implementation.typeParameters)>(<args(fc.parameters)>);
}
>>


param_type(p) ::= <<
<if(p.varArgs)><p.type.componentType>...<else><p.type><endif>
>>

params(params) ::= <<
<params:{p |<param_type(p)> <p.name>}; separator=",\n">
>>

args(params) ::= <<
<params:{p |<p.name>}; separator=",">
>>

throws_spec(thrownTypes) ::= <<
<if(thrownTypes)>throws <thrownTypes:{t |<t>}; separator=",\n"> <endif>
>>

generic_params(tp) ::= <<
<if(tp)>\<<tp:{t |<type_parameter(t)>}; separator=", ">\><endif>
>>

generic_args(tp) ::= <<
<if(tp)>\<<tp; separator=", ">\><endif>
>>

type_parameter(t) ::= <<
<t><if(t.bounds)> extends <t.bounds; separator=" & "><endif>
>>
